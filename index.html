<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete 3D Floorplan</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f5f5f5; font-family: Arial, sans-serif; }
        #plan-container { width: 100vw; height: 100vh; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 300px;
        }
        #info h3 { margin: 0 0 10px 0; color: #333; font-size: 16px; }
        #info p { margin: 5px 0; color: #666; font-size: 13px; line-height: 1.5; }
    </style>
</head>
<body>
    <div id="plan-container"></div>
    <div id="info">
        <h3>üè† Complete Living Room</h3>
        <p><strong>Furniture:</strong> Sofas, tables, TV unit, dining set, shelves</p>
        <p><strong>Decor:</strong> Plants, vases, artwork, lamps</p>
        <p><strong>Tip:</strong> Rotate with mouse to explore!</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // --- 1. CONFIGURATION ---
        const LOCAL_PATH = "./models/";
        const REMOTE_PATH = "https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/";

        const modelLibrary = {
            // Living Room (Core 80%)
            "sofa": LOCAL_PATH + "sofa.glb",
            "table": LOCAL_PATH + "table.glb",
            "chair": REMOTE_PATH + "SheenChair/glTF-Binary/SheenChair.glb",
            "tv_stand": LOCAL_PATH + "tv_stand.glb",
            
            // Kitchen (Core 80%)
            "refrigerator": LOCAL_PATH + "refrigerator.glb",
            "stove": LOCAL_PATH + "stove.glb",
            "kitchen_cabinet": LOCAL_PATH + "kitchen_cabinet.glb",
            "kitchen_counter": LOCAL_PATH + "kitchen_counter.glb",
            "sink": LOCAL_PATH + "sink.glb",
            
            // Bedroom (Core 80%)
            "bed": LOCAL_PATH + "bed.glb",
            "nightstand": LOCAL_PATH + "nightstand.glb",
            "wardrobe": LOCAL_PATH + "wardrobe.glb",
            "dresser": LOCAL_PATH + "dresser.glb",
            
            // Bathroom (Core 80%)
            "toilet": LOCAL_PATH + "toilet.glb",
            "bathtub": LOCAL_PATH + "bathtub.glb",
            "bathroom_sink": LOCAL_PATH + "bathroom_sink.glb",
            "shower": LOCAL_PATH + "shower.glb",
            "bathroom_cabinet": LOCAL_PATH + "bathroom_cabinet.glb",
            
            // Universal/Architectural
            "door": LOCAL_PATH + "door.glb",
            "window": LOCAL_PATH + "window.glb",
            
            // Decor (Essential)
            "lamp": LOCAL_PATH + "lamp.glb",
            "plant": LOCAL_PATH + "plant.glb",
            
            // Optional/Legacy
            "table_and_chair": LOCAL_PATH + "table_and_chair.glb",
            "electronics": REMOTE_PATH + "BoomBox/glTF-Binary/BoomBox.glb",
            "vase": LOCAL_PATH + "vase.glb",
            "artwork": LOCAL_PATH + "artwork.glb",
            "shelf": null,
            "rug": null
        };

        // --- 2. FLOORPLAN DATA ---
        const data = {
            "walls": [
                { "id": "w_ext_l", "path": [[0, 0], [0, 8.8]], "thickness": 0.3, "height": 3 },
                { "id": "w_ext_t", "path": [[0, 8.8], [13.8, 8.8]], "thickness": 0.3, "height": 3 },
                { "id": "w_ext_r", "path": [[13.8, 8.8], [13.8, 0]], "thickness": 0.3, "height": 3 },
                { "id": "w_ext_b", "path": [[13.8, 0], [0, 0]], "thickness": 0.3, "height": 3 },
                { "id": "w_int_vert_1", "path": [[5.0, 0], [5.0, 8.8]], "thickness": 0.15, "height": 3 },
                { "id": "w_int_horiz_beds", "path": [[0, 4.4], [5.0, 4.4]], "thickness": 0.15, "height": 3 },
                { "id": "w_int_vert_2", "path": [[8.0, 0], [8.0, 8.8]], "thickness": 0.15, "height": 3 },
                { "id": "w_int_bath_hall", "path": [[5.0, 5.5], [8.0, 5.5]], "thickness": 0.15, "height": 3 },
                { "id": "w_int_bed2_ensuite", "path": [[8.0, 4.8], [13.8, 4.8]], "thickness": 0.15, "height": 3 }
            ],
            "rooms": [
                { "id": "r_bed1", "name": "Bedroom 1", "center": [2.5, 6.5] },
                { "id": "r_bed3", "name": "Bedroom 3", "center": [2.5, 2.3] },
                { "id": "r_bath", "name": "Bathroom", "center": [6.5, 7.0] },
                { "id": "r_bed2", "name": "Bedroom 2", "center": [10.8, 6.7] },
                { "id": "r_ensuite", "name": "Ensuite", "center": [10.8, 4.0] },
                { "id": "r_hall", "name": "Hallway", "center": [6.5, 2.7] },
                { "id": "r_living", "name": "Living Area", "center": [10.8, 2.0] }
            ],
            "openings": [
                { "id": "door_main", "type": "door", "host": "w_ext_b", "at": 6.5, "width": 1.2, "height": 2.2 },
                { "id": "win_bed1", "type": "window", "host": "w_ext_l", "at": 6.5, "width": 1.5, "height": 1.2, "sill": 1.0 },
                { "id": "win_bed3", "type": "window", "host": "w_ext_l", "at": 2.3, "width": 1.5, "height": 1.2, "sill": 1.0 },
                { "id": "win_living", "type": "window", "host": "w_ext_r", "at": 2.5, "width": 2.0, "height": 1.5, "sill": 0.8 },
                { "id": "door_bed1", "type": "door", "host": "w_int_vert_1", "at": 6.5, "width": 0.9, "height": 2.1 },
                { "id": "door_bed3", "type": "door", "host": "w_int_vert_1", "at": 2.3, "width": 0.9, "height": 2.1 },
                { "id": "door_bath", "type": "door", "host": "w_int_bath_hall", "at": 6.5, "width": 0.8, "height": 2.1 } // Fixed relative position
            ],
            // FURNITURE IS NOW ORGANIZED BY ROOM FOR EASY CHECKING
            "furniture": [
                // --- BEDROOM 1 (Top Left) ---
                // Bed head against Top Wall
                { "category": "bed", "position": [2.5, 6.8], "dimensions": [1.6, 2.0], "rotation": 0, "height": 0.6 },
                { "category": "nightstand", "position": [1.4, 7.8], "dimensions": [0.5, 0.4], "rotation": 0, "height": 0.5 },
                { "category": "nightstand", "position": [3.6, 7.8], "dimensions": [0.5, 0.4], "rotation": 0, "height": 0.5 },
                { "category": "wardrobe", "position": [4.5, 6.5], "dimensions": [0.6, 1.8], "rotation": 90, "height": 2.0 },
                { "category": "rug", "position": [2.5, 6.0], "dimensions": [2.5, 3.0], "rotation": 0, "height": 0 },

                // --- BEDROOM 3 (Bottom Left) ---
                // Bed head against Left Wall
                { "category": "bed", "position": [2.2, 2.3], "dimensions": [1.6, 2.0], "rotation": 90, "height": 0.6 },
                { "category": "nightstand", "position": [1.0, 1.0], "dimensions": [0.5, 0.4], "rotation": 90, "height": 0.5 },
                { "category": "wardrobe", "position": [4.2, 3.8], "dimensions": [0.6, 1.5], "rotation": 0, "height": 2.0 },
                { "category": "plant", "position": [0.5, 4.0], "dimensions": [0.5, 0.5], "rotation": 0, "height": 1.0 },

                // --- BEDROOM 2 (Top Right) ---
                // Bed head against Right Wall
                { "category": "bed", "position": [11.5, 6.7], "dimensions": [1.8, 2.0], "rotation": -90, "height": 0.6 },
                { "category": "wardrobe", "position": [8.5, 6.7], "dimensions": [0.6, 1.8], "rotation": 0, "height": 2.0 },
                { "category": "nightstand", "position": [13.0, 7.9], "dimensions": [0.5, 0.4], "rotation": -90, "height": 0.5 },
                
                // --- BATHROOM (Top Middle) ---
                { "category": "bathtub", "position": [6.5, 8.0], "dimensions": [1.7, 0.75], "rotation": 0, "height": 0.6 },
                { "category": "bathroom_sink", "position": [5.5, 6.0], "dimensions": [0.6, 0.5], "rotation": 180, "height": 0.85 },
                { "category": "toilet", "position": [7.5, 6.0], "dimensions": [0.5, 0.7], "rotation": 180, "height": 0.45 },

                // --- ENSUITE (Middle Right) ---
                { "category": "shower", "position": [12.8, 4.0], "dimensions": [0.9, 0.9], "rotation": 0, "height": 2.0 },
                { "category": "toilet", "position": [9.0, 3.6], "dimensions": [0.5, 0.7], "rotation": 0, "height": 0.45 },
                { "category": "bathroom_sink", "position": [10.5, 3.6], "dimensions": [0.6, 0.5], "rotation": 0, "height": 0.85 },

                // --- LIVING AREA (Bottom Right - formerly "Void") ---
                // TV on Right Wall, Sofa facing it
                { "category": "tv_stand", "position": [13.2, 2.0], "dimensions": [0.5, 1.8], "rotation": -90, "height": 0.5 },
                { "category": "sofa", "position": [10.0, 2.0], "dimensions": [0.9, 2.2], "rotation": 90, "height": 0.8 },
                { "category": "table", "position": [11.5, 2.0], "dimensions": [0.6, 1.0], "rotation": 90, "height": 0.4 },
                { "category": "rug", "position": [11.5, 2.0], "dimensions": [2.5, 3.5], "rotation": 90, "height": 0 },
                { "category": "lamp", "position": [8.5, 0.5], "dimensions": [0.5, 0.5], "rotation": 0, "height": 1.5 },
                { "category": "artwork", "position": [13.4, 2.0], "dimensions": [0.05, 1.2], "rotation": -90, "height": 0.8 } // Mounted on wall
            ]
        };

        // --- 3. PROCEDURAL OBJECT CREATION ---
        function createPlant(width, height) {
            const group = new THREE.Group();
            
            // Pot
            const potGeo = new THREE.CylinderGeometry(width * 0.4, width * 0.5, height * 0.25, 8);
            const potMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const pot = new THREE.Mesh(potGeo, potMat);
            pot.position.y = height * 0.125;
            pot.castShadow = true;
            pot.receiveShadow = true;
            group.add(pot);
            
            // Soil
            const soilGeo = new THREE.CircleGeometry(width * 0.38, 8);
            const soilMat = new THREE.MeshLambertMaterial({ color: 0x3d2817 });
            const soil = new THREE.Mesh(soilGeo, soilMat);
            soil.rotation.x = -Math.PI / 2;
            soil.position.y = height * 0.25;
            group.add(soil);
            
            // Leaves (spheres to represent foliage)
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            for (let i = 0; i < 5; i++) {
                const leafSize = width * (0.3 + Math.random() * 0.3);
                const leaf = new THREE.Mesh(new THREE.SphereGeometry(leafSize, 8, 8), leafMat);
                const angle = (i / 5) * Math.PI * 2;
                leaf.position.x = Math.cos(angle) * width * 0.3;
                leaf.position.z = Math.sin(angle) * width * 0.3;
                leaf.position.y = height * 0.5 + Math.random() * height * 0.4;
                leaf.castShadow = true;
                group.add(leaf);
            }
            
            return group;
        }

        function createVase(width, height) {
            const group = new THREE.Group();
            
            const vaseGeo = new THREE.CylinderGeometry(width * 0.3, width * 0.4, height, 8);
            const vaseMat = new THREE.MeshStandardMaterial({ 
                color: 0xE8E8E8,
                metalness: 0.2,
                roughness: 0.5
            });
            const vase = new THREE.Mesh(vaseGeo, vaseMat);
            vase.position.y = height / 2;
            vase.castShadow = true;
            vase.receiveShadow = true;
            group.add(vase);
            
            // Flower stems
            const stemMat = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            for (let i = 0; i < 3; i++) {
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(width * 0.02, width * 0.02, height * 0.8, 4),
                    stemMat
                );
                const angle = (i / 3) * Math.PI * 2;
                stem.position.x = Math.cos(angle) * width * 0.15;
                stem.position.z = Math.sin(angle) * width * 0.15;
                stem.position.y = height * 0.9;
                
                // Flower head
                const flowerMat = new THREE.MeshLambertMaterial({ 
                    color: [0xFF69B4, 0xFF6347, 0xFFD700][i]
                });
                const flower = new THREE.Mesh(
                    new THREE.SphereGeometry(width * 0.15, 6, 6),
                    flowerMat
                );
                flower.position.y = height * 0.4;
                stem.add(flower);
                
                group.add(stem);
            }
            
            return group;
        }

        function createLamp(width, height) {
            const group = new THREE.Group();
            
            // Base
            const baseGeo = new THREE.CylinderGeometry(width * 0.4, width * 0.5, height * 0.15, 8);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A, metalness: 0.6 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = height * 0.075;
            base.castShadow = true;
            group.add(base);
            
            // Pole
            const poleGeo = new THREE.CylinderGeometry(width * 0.05, width * 0.05, height * 0.7, 8);
            const pole = new THREE.Mesh(poleGeo, baseMat);
            pole.position.y = height * 0.5;
            pole.castShadow = true;
            group.add(pole);
            
            // Shade
            const shadeGeo = new THREE.CylinderGeometry(width * 0.7, width * 0.5, height * 0.3, 8);
            const shadeMat = new THREE.MeshStandardMaterial({ 
                color: 0xFFFACD,
                emissive: 0xFFFF99,
                emissiveIntensity: 0.3
            });
            const shade = new THREE.Mesh(shadeGeo, shadeMat);
            shade.position.y = height * 0.85;
            shade.castShadow = true;
            group.add(shade);
            
            return group;
        }

        function createShelf(width, depth, height) {
            const group = new THREE.Group();
            const shelfMat = new THREE.MeshLambertMaterial({ color: 0x8B7355 });
            
            // Create 3-4 shelves
            const numShelves = Math.floor(height / 0.4) + 1;
            for (let i = 0; i < numShelves; i++) {
                const shelf = new THREE.Mesh(
                    new THREE.BoxGeometry(depth, 0.05, width),
                    shelfMat
                );
                shelf.position.y = (i / (numShelves - 1)) * height;
                shelf.castShadow = true;
                shelf.receiveShadow = true;
                group.add(shelf);
            }
            
            // Side panels
            const sideMat = new THREE.MeshLambertMaterial({ color: 0x6B5345 });
            const leftSide = new THREE.Mesh(
                new THREE.BoxGeometry(depth, height, 0.05),
                sideMat
            );
            leftSide.position.z = -width / 2;
            leftSide.position.y = height / 2;
            group.add(leftSide);
            
            const rightSide = leftSide.clone();
            rightSide.position.z = width / 2;
            group.add(rightSide);
            
            return group;
        }

        function createArtwork(width, depth, height) {
            const group = new THREE.Group();
            
            // Frame
            const frameGeo = new THREE.BoxGeometry(depth, height, width);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x2C2C2C });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.castShadow = true;
            group.add(frame);
            
            // Canvas
            const canvasGeo = new THREE.BoxGeometry(depth * 0.5, height * 0.9, width * 0.9);
            const canvasMat = new THREE.MeshStandardMaterial({ 
                color: Math.random() > 0.5 ? 0x4A90E2 : 0xE2A14A
            });
            const canvas = new THREE.Mesh(canvasGeo, canvasMat);
            canvas.position.x = depth * 0.25;
            group.add(canvas);
            
            return group;
        }

        function createRug(width, depth) {
            const rugGeo = new THREE.BoxGeometry(depth, 0.02, width);
            const rugMat = new THREE.MeshStandardMaterial({ 
                color: 0xC19A6B,
                roughness: 0.9
            });
            const rug = new THREE.Mesh(rugGeo, rugMat);
            rug.position.y = 0.01; // Slightly above floor to prevent z-fighting
            rug.receiveShadow = true;
            return rug;
        }

        // --- 4. RENDER LOGIC ---
        (function() {
            const container = document.getElementById("plan-container");
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);

            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(8, 20, 18);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(5, 0, 5);
            controls.update();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(15, 25, 15);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // --- UPDATED FLOOR LOGIC ---
            
            // 1. Calculate the bounding box of the walls dynamically
            let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
            
            data.walls.forEach(w => {
                w.path.forEach(point => {
                    const [x, z] = point;
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                    if (z < minZ) minZ = z;
                    if (z > maxZ) maxZ = z;
                });
            });

            // 2. Determine size and center
            const houseWidth = maxX - minX;
            const houseDepth = maxZ - minZ;
            const centerX = (minX + maxX) / 2;
            const centerZ = (minZ + maxZ) / 2;
            const padding = 2; // Add extra space around the house

            // 3. Create the floor
            const floorGeo = new THREE.PlaneGeometry(houseWidth + padding, houseDepth + padding);
            const floorMat = new THREE.MeshStandardMaterial({ 
                color: 0xD2B48C,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            
            // 4. Center the floor exactly under the house
            floor.position.set(centerX, 0, centerZ); 
            floor.receiveShadow = true;
            scene.add(floor);

            // 5. Update controls to look at the center of the house
            controls.target.set(centerX, 0, centerZ);
            controls.update();

            // ---------------------------

            const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.ShadowMaterial({ opacity: 0.1 }));
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.01;
            ground.receiveShadow = true;
            scene.add(ground);

            const wallsById = {};
            const group = new THREE.Group();
            scene.add(group);

            // Helpers
            const matWall = new THREE.MeshLambertMaterial({ color: 0xf8f8f8 });
            const matFallback = new THREE.MeshLambertMaterial({ color: 0x9ca3af });
            
            function createBox(w, h, d, material, x, y, z, rotY) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), material);
                mesh.position.set(x, y, z);
                mesh.rotation.y = rotY || 0;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                return mesh;
            }

            // Walls
            data.walls.forEach(w => {
                const dx = w.path[1][0] - w.path[0][0];
                const dz = w.path[1][1] - w.path[0][1];
                const len = Math.sqrt(dx*dx + dz*dz);
                const ang = Math.atan2(dz, dx);
                
                wallsById[w.id] = { x1: w.path[0][0], z1: w.path[0][1], angle: ang, thickness: w.thickness };

                const wallOpenings = (data.openings || [])
                    .filter(op => op.host === w.id)
                    .sort((a, b) => a.at - b.at);

                let currentX = 0;

                wallOpenings.forEach(op => {
                    const opStart = op.at - (op.width / 2);
                    const opEnd = op.at + (op.width / 2);
                    const opHeight = op.height;
                    const opSill = op.sill || 0;

                    if (opStart > currentX) {
                        const segLen = opStart - currentX;
                        const segMid = currentX + segLen / 2;
                        const mx = w.path[0][0] + Math.cos(ang) * segMid;
                        const mz = w.path[0][1] + Math.sin(ang) * segMid;
                        group.add(createBox(segLen, w.height, w.thickness, matWall, mx, w.height/2, mz, -ang));
                    }

                    if (opSill > 0) {
                        const mx = w.path[0][0] + Math.cos(ang) * op.at;
                        const mz = w.path[0][1] + Math.sin(ang) * op.at;
                        group.add(createBox(op.width, opSill, w.thickness, matWall, mx, opSill/2, mz, -ang));
                    }

                    const lintelHeight = w.height - (opSill + opHeight);
                    if (lintelHeight > 0) {
                        const mx = w.path[0][0] + Math.cos(ang) * op.at;
                        const mz = w.path[0][1] + Math.sin(ang) * op.at;
                        const ly = (opSill + opHeight) + lintelHeight/2;
                        group.add(createBox(op.width, lintelHeight, w.thickness, matWall, mx, ly, mz, -ang));
                    }

                    currentX = opEnd;
                });

                if (currentX < len) {
                    const segLen = len - currentX;
                    const segMid = currentX + segLen / 2;
                    const mx = w.path[0][0] + Math.cos(ang) * segMid;
                    const mz = w.path[0][1] + Math.sin(ang) * segMid;
                    group.add(createBox(segLen, w.height, w.thickness, matWall, mx, w.height/2, mz, -ang));
                }
            });

            // Load Models Function
            const loader = new THREE.GLTFLoader();
            
            function loadItem(item, type) {
                const rotY = (item.rotation || 0) * Math.PI / 180;
                let posX = 0, posY = 0, posZ = 0, rot = 0;
                let dimX = 0, dimY = 0, dimZ = 0;

                if (type === 'furniture') {
                    posX = item.position[0];
                    posZ = item.position[1];
                    posY = dimY / 2; // Position at half height to sit on floor
                    rot = rotY;
                    dimX = item.dimensions[0];
                    dimZ = item.dimensions[1];
                    dimY = item.height || 0.8;
                } else if (type === 'opening') {
                    const wall = wallsById[item.host];
                    if(!wall) return;
                    const dist = item.at;
                    posX = wall.x1 + Math.cos(wall.angle) * dist;
                    posZ = wall.z1 + Math.sin(wall.angle) * dist;
                    posY = (item.sill || 0) + item.height/2; 
                    rot = -wall.angle;
                    dimX = item.width;
                    dimY = item.height;
                    dimZ = wall.thickness + 0.1;
                }

                // 1. Try loading from Model Library (GLB)
                const url = modelLibrary[item.category || item.type];
                
                if (url) {
                    loader.load(url, (gltf) => {
                        const model = gltf.scene;
                        const wrapper = new THREE.Group();
                        wrapper.position.set(posX, 0, posZ);
                        wrapper.rotation.y = rot;

                        const box = new THREE.Box3().setFromObject(model);
                        const size = box.getSize(new THREE.Vector3());
                        const center = box.getCenter(new THREE.Vector3());

                        model.position.x = -center.x;
                        model.position.y = -box.min.y;
                        model.position.z = -center.z;
                        
                        const scX = dimX / (size.x || 1);
                        const scY = dimY / (size.y || 1);
                        const scZ = dimZ / (size.z || 1);
                        
                        if (type === 'opening') {
                            model.scale.set(scX, scY, scZ);
                            wrapper.position.y = posY - (dimY/2);
                        } else {
                            const minSc = Math.min(scX, scZ) * 0.9;
                            model.scale.set(minSc, minSc, minSc);
                        }

                        model.traverse(n => { if(n.isMesh) { n.castShadow = true; n.receiveShadow = true; } });
                        wrapper.add(model);
                        group.add(wrapper);
                    }, undefined, (err) => {
                        console.error("Could not load model:", url, err);
                        // Fallback to box if load fails
                        group.add(createBox(dimX, dimY, dimZ, matFallback, posX, posY || dimY/2, posZ, rot));
                    });
                    return; // Stop here if we have a URL
                }

                // 2. Try Procedural Generation
                if (['plant', 'vase', 'lamp', 'shelf', 'artwork', 'rug'].includes(item.category)) {
                    let obj;
                    
                    switch(item.category) {
                        case 'plant':
                            obj = createPlant(dimX, dimY);
                            break;
                        case 'vase':
                            obj = createVase(dimX, dimY);
                            break;
                        case 'lamp':
                            obj = createLamp(dimX, dimY);
                            break;
                        case 'shelf':
                            obj = createShelf(dimZ, dimX, dimY);
                            break;
                        case 'artwork':
                            obj = createArtwork(dimZ, dimX, dimY);
                            break;
                        case 'rug':
                            obj = createRug(dimZ, dimX);
                            break;
                    }
                    
                    if (obj) {
                        obj.position.set(posX, 0, posZ); // Keep at floor level (y=0) for procedural objects
                        obj.rotation.y = rot;
                        group.add(obj);
                    }
                    return;
                }

                // 3. Fallback Box
                group.add(createBox(dimX, dimY, dimZ, matFallback, posX, posY || dimY/2, posZ, rot));
            }

            // Loop Data
            if (data.openings) data.openings.forEach(op => loadItem(op, 'opening'));
            if (data.furniture) data.furniture.forEach(f => loadItem(f, 'furniture'));

            // Animate
            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        })();
    </script>
</body>
</html>